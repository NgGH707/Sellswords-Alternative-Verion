::mods_hookExactClass("skills/effects/ptr_exploitable_opening_effect", function(o) {
	o.m.tempOpponents <- [];		
	o.m.IsPrimed <- false;

	o.addtempOpponent <- function(_entityID)
	{
		if (this.m.tempOpponents.find(_entityID) == null)
		{
			this.m.tempOpponents.push(_entityID);
		}
	}
	
	o.removetempOpponent <- function(_entityID)
	{
		local idx = this.m.tempOpponents.find(_entityID);
		if (idx != null)
		{
			this.m.tempOpponents.remove(idx);
		}
	}

	o.hasOpponent = function(_entityID)
	{
		return (this.m.Opponents.find(_entityID) != null || this.m.tempOpponents.find(_entityID) != null);
	}
	
	local ws_getTooltip = o.getTooltip;
	o.getTooltip = function()
	{
		local ret = ws_getTooltip();

		if (this.m.Opponents.len() != 0 && this.getContainer().hasSkill("perk.ptr_en_garde"))
		{
			ret.insert(3, {
				id = 10,
				type = "text",
				icon = "ui/icons/regular_damage.png",
				text = "[color=" + this.Const.UI.Color.NegativeValue + "]-" + this.m.HitChanceIncrease + "%[/color] Direct Damage against attacks from:"
			});		
		}	

		return ret;
	}

	o.onTurnStart = function()
	{	
		foreach (opponentID in this.m.tempOpponents)
		{
			local e = this.getOpponent(opponentID);
			if (e == null) continue;

			local perk = e.getSkills().getSkillByID("perk.ptr_exploit_opening");
			if (perk != null)
			{
				perk.removetempOpponent(this.getContainer().getActor().getID());
			}
		}
		this.m.tempOpponents.clear();		
		//this.m.tempOpponents = this.m.Opponents;
		foreach (opponentID in this.m.Opponents)
		{
			this.addtempOpponent(opponentID);		
		}
		this.m.Opponents.clear();
		if (this.m.tempOpponents.len() == 0)
		{
			this.removeSelf();
		}
	}

	o.onDeath = function( _fatalityType )
	{
		foreach (opponentID in this.m.Opponents)
		{
			local e = this.getOpponent(opponentID);
			if (e == null) continue;

			local perk = e.getSkills().getSkillByID("perk.ptr_exploit_opening");
			if (perk != null)
			{
				perk.removeOpponent(this.getContainer().getActor().getID());
			}
		}
		
		foreach (opponentID in this.m.tempOpponents)
		{
			local e = this.getOpponent(opponentID);
			if (e == null) continue;

			local effect = e.getSkills().getSkillByID("effects.ptr_exploitable_opening");
			if (effect != null)
			{
				effect.removetempOpponent(this.getContainer().getActor().getID());
			}
		}		
	}

	o.onTurnEnd = function()
	{
		if (this.m.Opponents.len() == 0 && this.m.tempOpponents.len() == 0 )
		{
			this.removeSelf();
		}
	}

})