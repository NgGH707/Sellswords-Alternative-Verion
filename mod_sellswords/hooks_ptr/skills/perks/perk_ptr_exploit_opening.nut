::mods_hookExactClass("skills/perks/perk_ptr_exploit_opening", function ( o )
{
	o.m.tempOpponents <- [];		
	o.m.IsRiposting <- false;
	o.m.DamageMalusIncreasePerProc <- 10;
	o.m.ProcCount <- 0;
	o.m.DamageMalus <- 0;
	o.m.IsValid <- true;
	o.m.Skills <- [
		"actives.overhead_strike"
	];

	o.isHidden = function()
	{
		return this.m.Opponents.len() == 0 && this.m.tempOpponents.len() == 0;
	}

	local ws_onCombatFinished = o.onCombatFinished;
	o.onCombatFinished = function()
	{
		ws_onCombatFinished();
		this.m.tempOpponents.clear();		
	}

	o.addtempOpponent <- function(_entityID)
	{
		if (this.m.tempOpponents.find(_entityID) == null)
		{
			this.m.tempOpponents.push(_entityID);
		}
	}

	o.removetempOpponent <- function(_entityID)
	{
		local idx = this.m.tempOpponents.find(_entityID);
		if (idx != null)
		{
			this.m.tempOpponents.remove(idx);
		}
	}

	o.hasOpponent <- function(_entityID)
	{
		return (this.m.Opponents.find(_entityID) != null || this.m.tempOpponents.find(_entityID) != null);
	}	
	
	o.getCurrentMalus <- function()
	{
		return this.Math.min(50, this.m.DamageMalus + (this.m.ProcCount * this.m.DamageMalusIncreasePerProc));
	}

	o.getTooltip = function()
	{
		local tooltip = this.skill.getTooltip();

		tooltip.push(
			{
				id = 10,
				type = "text",
				icon = "ui/icons/melee_skill.png",
				text = "[color=" + this.Const.UI.Color.NegativeValue + "]+" + 10 + "[/color] Melee Skill when attacking:"
			}
		);

		tooltip.push(
			{
				id = 10,
				type = "text",
				icon = "ui/icons/regular_damage.png",
				text = "[color=" + this.Const.UI.Color.NegativeValue + "]+" + 5 + "%[/color] Direct Damage when attacking:"
			}
		);		
		
		foreach (opponentID in this.m.Opponents)
		{
			local e = this.getOpponent(opponentID);
			if (e == null) continue;
			tooltip.push(
				{
					id = 10,
					type = "text",
					icon = "ui/orientation/" + e.getOverlayImage() + ".png",
					text = e.getName()
				}
			);
		}
		
		foreach (opponentID in this.m.tempOpponents)
		{
			local e = this.getOpponent(opponentID);
			if (e != null && this.m.Opponents.find(e) != null)   //dont show same opponent twice
			{
				tooltip.push(
					{
						id = 10,
						type = "text",
						icon = "ui/orientation/" + e.getOverlayImage() + ".png",
						text = e.getName()
					}
				);
			}
		}		
				
		return tooltip;
	}

	o.canRiposte <- function()
	{
		local actor = this.getContainer().getActor();
		
		if (!this.getContainer().getSkillByID("perk.ptr_en_garde"))
		{
			return false;		
		}
		
		if (this.getContainer().getSkillByID("effects.disarmed") || this.getContainer().getSkillByID("effects.staggered") || this.getContainer().getSkillByID("effects.stunned"))
		{
			return false;		
		}		
		
		if (actor.getCurrentProperties().IsRiposting)
		{
			return false;				
		}		

		if (!actor.getCurrentProperties().IsAbleToUseWeaponSkills || !actor.hasZoneOfControl())
		{
			return false;
		}

		local weapon = actor.getMainhandItem();
		if (weapon == null || !weapon.isWeaponType(this.Const.Items.WeaponType.Sword))
		{
			return false;
		}

		return true;
	}

	o.onMissed = function( _attacker, _skill )
	{
		local actor = this.getContainer().getActor();
		//if (actor.getCurrentProperties().IsRiposting)
		//{	
		//	this.logInfo("is riposting");			
		//}		

		if (!actor.isPlacedOnMap() || actor.getMoraleState() == this.Const.MoraleState.Fleeing)
		{
			return;
		}

		if (_skill == null || !_skill.isAttack() || _skill.isRanged() || _attacker == null || _attacker.isAlliedWith(this.getContainer().getActor()))
		{
			return;
		}
		
		local attackerEffect = _attacker.getSkills().getSkillByID("effects.ptr_exploitable_opening");
		if (attackerEffect == null)                   //for those who doesnt have the effect, add it
		{
			local effect = this.new("scripts/skills/effects/ptr_exploitable_opening_effect");					
			effect.addOpponent(this.getContainer().getActor().getID());
			_attacker.getSkills().add(effect);
		}
		else										  //already in effect
		{
			local targetTile = _attacker.getTile();	
			//forbid loop 08.01
			local attackerPerk = _attacker.getSkills().getSkillByID("perk.ptr_exploit_opening");	
			if (attackerPerk != null && attackerPerk.hasOpponent(this.getContainer().getActor().getID()))
			{
				return;
			}
			if (this.m.IsValid && (this.m.Opponents.find(_attacker.getID()) != null  || this.m.tempOpponents.find(_attacker.getID()) != null) && targetTile.getDistanceTo(this.getContainer().getActor().getTile()) == 1 && this.canRiposte())	//riposte
			{		
				this.getContainer().setBusy(true);
				this.Time.scheduleEvent(this.TimeUnit.Virtual, 300, function ( effect )
				{
					this.m.IsRiposting = true;					
					if (!actor.isPlayerControlled() || (this.Tactical.TurnSequenceBar.getActiveEntity() != null && this.Tactical.TurnSequenceBar.getActiveEntity().getID() == actor.getID())) 
					{
						local isAbleToDie = _attacker.m.IsAbleToDie;					
						_attacker.m.IsAbleToDie = false;
						this.getContainer().getAttackOfOpportunity().useForFree(targetTile);
						if (_attacker.isAlive() && !_attacker.isDying())
						{						
							_attacker.m.IsAbleToDie = isAbleToDie;
						}						
					}
					else					
					{
						this.getContainer().getAttackOfOpportunity().useForFree(targetTile);						
					}
					this.m.ProcCount++;						
					this.m.IsRiposting = false;						
					this.getContainer().setBusy(false);

				}.bindenv(this), this);					
			}			
			else										//add new opponents	
			{
				attackerEffect.addOpponent(this.getContainer().getActor().getID());
			}
		}

		this.addOpponent(_attacker.getID());
	}

	o.onAnySkillUsed = function( _skill, _targetEntity, _properties )
	{
		if (_targetEntity != null)
		{
			local effect = _targetEntity.getSkills().getSkillByID("effects.ptr_exploitable_opening");
			if (effect != null && effect.hasOpponent(this.getContainer().getActor().getID()))
			{
				_properties.MeleeSkill += 10;						
				_properties.DamageDirectAdd += 0.05;
			}
		}
		if (this.m.IsRiposting)
		{
			_properties.DamageTotalMult *= 1.0 - this.getCurrentMalus() * 0.01;
			if (!this.getContainer().getActor().getCurrentProperties().IsSpecializedInSwords)
			{
				_properties.MeleeSkill -= 10;
			}
			
			local skills = this.getContainer().getSkillsByFunction((@(_skill) this.m.Skills.find(_skill.getID()) != null).bindenv(this));   //greatswords
			if (skills.len() != 0)
			{
				_properties.DamageTotalMult *= 0.666;
			}			
		}		
	}

	o.onTargetHit <- function( _skill, _targetEntity, _bodyPart, _damageInflictedHitpoints, _damageInflictedArmor )
	{
		//if (_targetEntity != null && !this.m.IsRiposting)
		//{
		//	local effect = _targetEntity.getSkills().getSkillByID("effects.ptr_exploitable_opening");
		//	local meisterhau = this.getContainer().getSkillByID("actives.ptr_swordmaster_versatile_swordsman_stance_meisterhau");
		//	if (meisterhau != null && meisterhau.m.IsOn)
		//	{
		//		return;
		//	}			
		//	if (effect != null && effect.hasOpponent(this.getContainer().getActor().getID()))
		//	{
		//		effect.removeOpponent(this.getContainer().getActor().getID());
		//		this.removeOpponent(_targetEntity.getID());	
		//		effect.removetempOpponent(this.getContainer().getActor().getID());
		//		this.removetempOpponent(_targetEntity.getID());					
		//	}
		//}
		local meisterhau = this.getContainer().getSkillByID("actives.ptr_swordmaster_versatile_swordsman_stance_meisterhau");
		if (meisterhau != null && meisterhau.m.IsOn)
		{
			if (_skill == null || !_skill.isAttack() || _skill.isRanged() || _targetEntity == null || _targetEntity.isAlliedWith(this.getContainer().getActor()))
			{
				return;
			}

			local attackerEffect = _targetEntity.getSkills().getSkillByID("effects.ptr_exploitable_opening");
			if (attackerEffect == null)                   //for those who doesnt have the effect, add it
			{
				local effect = this.new("scripts/skills/effects/ptr_exploitable_opening_effect");					
				effect.addOpponent(this.getContainer().getActor().getID());
				_targetEntity.getSkills().add(effect);
			}
			this.addOpponent(_targetEntity.getID());			
		}				
	}

	o.onDeath = function( _fatalityType )
	{

		foreach (opponentID in this.m.Opponents)
		{
			local e = this.getOpponent(opponentID);
			if (e == null) continue;

			local effect = e.getSkills().getSkillByID("effects.ptr_exploitable_opening");
			if (effect != null)
			{
				effect.removeOpponent(this.getContainer().getActor().getID());
			}
		}
		
		foreach (opponentID in this.m.tempOpponents)
		{
			local e = this.getOpponent(opponentID);
			if (e == null) continue;

			local effect = e.getSkills().getSkillByID("effects.ptr_exploitable_opening");
			if (effect != null)
			{
				effect.removetempOpponent(this.getContainer().getActor().getID());
			}
		}		
	}

	o.onTurnStart <- function()
	{
		local weapon = this.getContainer().getActor().getMainhandItem();
		if (weapon == null || !weapon.isWeaponType(this.Const.Items.WeaponType.Sword))
		{
			this.m.IsValid = false;
		}
		this.m.ProcCount = 0;		 //reset riposte count 08.01
	}

	o.onTurnEnd = function()
	{
		foreach (opponentID in this.m.tempOpponents)		//remove opponents list in effect
		{
			local e = this.getOpponent(opponentID);
			if (e == null) continue;

			local effect = e.getSkills().getSkillByID("effects.ptr_exploitable_opening");
			if (effect != null)
			{

				effect.removetempOpponent(this.getContainer().getActor().getID());
			}
		}	
		//this.m.tempOpponents.clear();          //remove opponents list in perk
		//this.m.tempOpponents = this.m.Opponents;    //one turn has passed	
		this.m.tempOpponents.clear();		
		foreach (opponentID in this.m.Opponents)
		{
			this.addtempOpponent(opponentID);		
		}		
		this.m.Opponents.clear();
		this.m.IsValid = true;		
	}

});	